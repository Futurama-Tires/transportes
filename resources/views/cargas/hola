ApiService.kt:

package com.example.transportes.data.remote

import retrofit2.http.*

// ===================== PING / AUTH =====================

data class PingResponse(val pong: Boolean, val time: String)

data class LoginRequest(
    val email: String,
    val password: String,
    val device_name: String = "android-phone"
)

data class User(
    val id: Int,
    val name: String,
    val email: String
)

data class LoginResponse(
    val message: String,
    val token: String,
    val token_type: String,
    val user: User
)

// ===================== CARGAS: DTOs =====================

// Request para crear una carga desde la app (SIN operador_id; lo infiere el backend)
// Importante: NO se env√≠a km_inicial; el servidor lo toma del od√≥metro del veh√≠culo.
// km_final es OBLIGATORIO en m√≥vil.
data class CargaRequest(
    val ubicacion: String?,          // opcional
    val fecha: String,               // "YYYY-MM-DD"
    val precio: Double,              // ej: 24.59
    val tipo_combustible: String,    // "Magna" | "Diesel" | "Premium"
    val litros: Double,              // ej: 45.123
    val custodio: String?,           // opcional
    val vehiculo_id: Int,            // requerido
    val km_final: Int,               // requerido (od√≥metro al terminar la carga)
    val destino: String?,            // opcional
    val observaciones: String?       // opcional
)

// Resumen de veh√≠culo/operador incluidos en la respuesta
data class VehiculoMin(
    val id: Int,
    val unidad: String?,
    val placa: String?,
    val kilometros: Int?              // üëà od√≥metro actual para mostrar KM inicial en la UI
)

data class OperadorMin(
    val id: Int,
    val nombre: String?,
    val apellido_paterno: String?,
    val apellido_materno: String?
)

// Respuesta que devuelve Laravel al crear la carga (incluye relaciones)
data class CargaResponse(
    val id: Int,
    val ubicacion: String?,
    val fecha: String,
    val mes: String?,               // calculado en backend
    val precio: String,             // decimal -> string en Laravel
    val tipo_combustible: String,
    val litros: String,             // decimal -> string
    val custodio: String?,
    val operador_id: Int,
    val vehiculo_id: Int,
    val km_inicial: Int?,           // lo fija el backend desde el od√≥metro/carga previa
    val km_final: Int?,
    val recorrido: Int?,
    val rendimiento: String?,       // decimal -> string
    val diferencia: String?,        // decimal -> string
    val total: String?,             // decimal -> string
    val destino: String?,
    val observaciones: String?,
    val created_at: String?,
    val updated_at: String?,
    val vehiculo: VehiculoMin?,     // relaci√≥n cargada
    val operador: OperadorMin?      // relaci√≥n cargada
)

// Cat√°logos para llenar selects del formulario m√≥vil
data class CatalogoCargas(
    val ubicaciones: List<String>,
    val tipos: List<String>
)

// ===================== API =====================

interface ApiService {

    // --- Salud / Auth ---
    @GET("api/ping")
    suspend fun ping(): PingResponse

    @POST("api/login")
    suspend fun login(@Body body: LoginRequest): LoginResponse

    @GET("api/me")
    suspend fun me(): User

    @POST("api/logout")
    suspend fun logout(): Map<String, String>

    // --- Cat√°logos / Veh√≠culos ---
    // Debe devolver 'kilometros' para autorrellenar KM inicial en la UI
    @GET("api/vehiculos-min")
    suspend fun vehiculosMin(): List<VehiculoMin>

    @GET("api/catalogos/cargas")
    suspend fun catalogosCargas(): CatalogoCargas

    // --- Registrar carga (operador_id se infiere del token en el backend) ---
    @POST("api/cargas")
    suspend fun registrarCarga(@Body body: CargaRequest): CargaResponse
}


RegistrarCargaAcitivy.kt:

package com.example.transportes.ui.cargas

import android.app.DatePickerDialog
import android.os.Bundle
import android.view.View
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.example.transportes.R
import com.example.transportes.data.remote.*
import com.example.transportes.data.remote.ApiClient
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import retrofit2.HttpException
import java.text.SimpleDateFormat
import java.util.*

class RegistrarCargaActivity : AppCompatActivity() {

    // Spinners
    private lateinit var spVehiculo: Spinner
    private lateinit var spUbicacion: Spinner
    private lateinit var spTipo: Spinner

    // Inputs
    private lateinit var etFecha: EditText
    private lateinit var etPrecio: EditText
    private lateinit var etLitros: EditText
    private lateinit var etCustodio: EditText
    private lateinit var etKmInicial: EditText
    private lateinit var etKmFinal: EditText
    private lateinit var etDestino: EditText
    private lateinit var etObservaciones: EditText

    // UI
    private lateinit var btnGuardar: Button
    private lateinit var progress: ProgressBar
    private lateinit var overlay: View

    // Datos cargados desde API
    private var vehiculos: List<VehiculoMin> = emptyList()
    private var ubicaciones: List<String> = emptyList()
    private var tipos: List<String> = emptyList()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_registrar_carga)

        bindViews()
        setDefaultDate()
        wireDatePicker()
        wireVehiculoListener()
        loadCatalogs()

        btnGuardar.setOnClickListener { onGuardar() }
    }

    private fun bindViews() {
        spVehiculo = findViewById(R.id.spVehiculo)
        spUbicacion = findViewById(R.id.spUbicacion)
        spTipo = findViewById(R.id.spTipo)

        etFecha = findViewById(R.id.etFecha)
        etPrecio = findViewById(R.id.etPrecio)
        etLitros = findViewById(R.id.etLitros)
        etCustodio = findViewById(R.id.etCustodio)
        etKmInicial = findViewById(R.id.etKmInicial)
        etKmFinal = findViewById(R.id.etKmFinal)
        etDestino = findViewById(R.id.etDestino)
        etObservaciones = findViewById(R.id.etObservaciones)

        btnGuardar = findViewById(R.id.btnGuardar)
        progress = findViewById(R.id.progress)
        overlay = findViewById(R.id.overlay)

        // KM inicial en solo lectura
        etKmInicial.isEnabled = false
        etKmInicial.isFocusable = false
        etKmInicial.isClickable = false
    }

    private fun setDefaultDate() {
        val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.US)
        etFecha.setText(sdf.format(Date()))
    }

    private fun wireDatePicker() {
        etFecha.setOnClickListener {
            val cal = Calendar.getInstance()
            val parts = etFecha.text.toString().split("-")
            if (parts.size == 3) {
                cal.set(Calendar.YEAR, parts[0].toInt())
                cal.set(Calendar.MONTH, parts[1].toInt() - 1)
                cal.set(Calendar.DAY_OF_MONTH, parts[2].toInt())
            }
            DatePickerDialog(
                this,
                { _, y, m, d ->
                    val mm = (m + 1).toString().padStart(2, '0')
                    val dd = d.toString().padStart(2, '0')
                    etFecha.setText("$y-$mm-$dd")
                },
                cal.get(Calendar.YEAR),
                cal.get(Calendar.MONTH),
                cal.get(Calendar.DAY_OF_MONTH)
            ).show()
        }
    }

    private fun wireVehiculoListener() {
        spVehiculo.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>, view: View?, position: Int, id: Long) {
                updateKmInicialFromSelection()
            }
            override fun onNothingSelected(parent: AdapterView<*>) {}
        }
    }

    private fun loadCatalogs() {
        setLoading(true)
        lifecycleScope.launch {
            try {
                val api = ApiClient.createService(this@RegistrarCargaActivity)

                // Llamadas (secuenciales; suficiente aqu√≠)
                val vehiculosResp = withContext(Dispatchers.IO) { api.vehiculosMin() }
                val catalogosResp = withContext(Dispatchers.IO) { api.catalogosCargas() }

                vehiculos = vehiculosResp
                ubicaciones = catalogosResp.ubicaciones
                tipos = catalogosResp.tipos

                // Poblamos spinners
                fillVehiculos()
                fillUbicaciones()
                fillTipos()

                // Inicializa KM inicial con la selecci√≥n actual (si hay datos)
                updateKmInicialFromSelection()

            } catch (e: Exception) {
                showError(parseError(e))
            } finally {
                setLoading(false)
            }
        }
    }

    private fun fillVehiculos() {
        val labels = vehiculos.map { v ->
            val unidad = v.unidad ?: "Unidad ${v.id}"
            val placa = v.placa ?: "‚Äî"
            "$unidad ¬∑ $placa"
        }
        spVehiculo.adapter = ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, labels)
    }

    private fun fillUbicaciones() {
        val items = listOf("‚Äî Selecciona ‚Äî") + ubicaciones
        spUbicacion.adapter = ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, items)
    }

    private fun fillTipos() {
        spTipo.adapter = ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, tipos)
    }

    private fun updateKmInicialFromSelection() {
        val pos = spVehiculo.selectedItemPosition
        val km = if (pos in vehiculos.indices) vehiculos[pos].kilometros else null
        etKmInicial.setText(km?.toString() ?: "")
    }

    private fun onGuardar() {
        // Validaciones m√≠nimas
        val fecha = etFecha.text.toString().trim()
        val precio = etPrecio.text.toString().trim().toDoubleOrNull()
        val litros = etLitros.text.toString().trim().toDoubleOrNull()

        if (fecha.isEmpty()) {
            etFecha.error = "Requerido"
            etFecha.requestFocus()
            return
        }
        if (precio == null || precio < 0) {
            etPrecio.error = "Precio inv√°lido"
            etPrecio.requestFocus()
            return
        }
        if (litros == null || litros <= 0) {
            etLitros.error = "Litros inv√°lidos"
            etLitros.requestFocus()
            return
        }
        if (vehiculos.isEmpty()) {
            showError("No hay veh√≠culos disponibles.")
            return
        }

        val vehiculoPos = spVehiculo.selectedItemPosition
        if (vehiculoPos !in vehiculos.indices) {
            showError("Selecciona un veh√≠culo.")
            return
        }
        val vehiculoId = vehiculos[vehiculoPos].id

        val ubicacion = spUbicacion.selectedItem?.toString()?.let {
            if (it.startsWith("‚Äî")) null else it
        }

        val tipo = spTipo.selectedItem?.toString()
        if (tipo.isNullOrBlank()) {
            showError("Selecciona el tipo de combustible.")
            return
        }

        val kmInicial = etKmInicial.text.toString().trim().toIntOrNull() // solo lectura; puede ser null
        val kmFinal = etKmFinal.text.toString().trim().toIntOrNull()
        if (kmFinal == null || kmFinal < 0) {
            etKmFinal.error = "KM final inv√°lido"
            etKmFinal.requestFocus()
            return
        }
        // Validaci√≥n: si hay od√≥metro previo, km_final >= km_inicial
        if (kmInicial != null && kmFinal < kmInicial) {
            etKmFinal.error = "KM final no puede ser menor que el od√≥metro ($kmInicial)"
            etKmFinal.requestFocus()
            return
        }

        val destino = etDestino.text.toString().trim().ifEmpty { null }
        val custodio = etCustodio.text.toString().trim().ifEmpty { null }
        val observaciones = etObservaciones.text.toString().trim().ifEmpty { null }

        val body = CargaRequest(
            ubicacion = ubicacion,
            fecha = fecha,
            precio = precio,
            tipo_combustible = tipo,
            litros = litros,
            custodio = custodio,
            vehiculo_id = vehiculoId,
            km_final = kmFinal,     // üëà requerido
            destino = destino,
            observaciones = observaciones
        )

        // Enviar
        setLoading(true)
        lifecycleScope.launch {
            try {
                val api = ApiClient.createService(this@RegistrarCargaActivity)
                val resp = withContext(Dispatchers.IO) { api.registrarCarga(body) }

                Toast.makeText(
                    this@RegistrarCargaActivity,
                    "Carga registrada (ID ${resp.id}).",
                    Toast.LENGTH_LONG
                ).show()
                finish()

            } catch (e: Exception) {
                showError(parseError(e))
            } finally {
                setLoading(false)
            }
        }
    }

    private fun setLoading(loading: Boolean) {
        overlay.visibility = if (loading) View.VISIBLE else View.GONE
        progress.visibility = if (loading) View.VISIBLE else View.GONE
        btnGuardar.isEnabled = !loading
    }

    private fun showError(msg: String) {
        Toast.makeText(this, msg, Toast.LENGTH_LONG).show()
    }

    private fun parseError(e: Exception): String {
        return when (e) {
            is HttpException -> {
                when (e.code()) {
                    401 -> "Sesi√≥n expirada. Vuelve a iniciar sesi√≥n."
                    422 -> "Datos inv√°lidos (verifica KM final y que tu usuario tenga operador)."
                    else -> "Error ${e.code()}: ${e.message()}"
                }
            }
            else -> e.message ?: "Error inesperado"
        }
    }
}

Modelo CargaCombustible:

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class CargaCombustible extends Model
{
    use HasFactory;

    protected $table = 'cargas_combustible';

    protected $fillable = [
        'ubicacion',
        'fecha',
        'precio',
        'tipo_combustible',
        'litros',
        'custodio',
        'operador_id',
        'vehiculo_id',
        'km_inicial',
        'km_final',
        'recorrido',
        'rendimiento',
        'diferencia',
        'total',
        'destino',
        'observaciones',
        // 'mes' lo calculamos; se guarda con forceFill() desde el controlador
    ];

    protected $casts = [
        'fecha'       => 'date:Y-m-d',
        'litros'      => 'decimal:3',
        'precio'      => 'decimal:2',
        'total'       => 'decimal:2',
        'rendimiento' => 'decimal:2',
        'diferencia'  => 'decimal:2',
        'km_inicial'  => 'integer',
        'km_final'    => 'integer',
        'recorrido'   => 'integer',
    ];

    // Opciones fijas conocidas
    public const UBICACIONES = ['Cuernavaca', 'Ixtapaluca', 'Queretaro', 'Vallejo', 'Guadalajara'];
    public const TIPOS_COMBUSTIBLE = ['Magna', 'Diesel', 'Premium'];

    public function operador()
    {
        return $this->belongsTo(Operador::class);
    }

    public function vehiculo()
    {
        return $this->belongsTo(Vehiculo::class);
    }

    /** Scope de filtros y ordenamiento (para la vista web) */
    public function scopeFilter($query, array $filters)
    {
        $query->leftJoin('vehiculos', 'vehiculos.id', '=', 'cargas_combustible.vehiculo_id')
              ->leftJoin('operadores', 'operadores.id', '=', 'cargas_combustible.operador_id')
              ->select('cargas_combustible.*');

        // --- B√öSQUEDA GLOBAL ---
        $query->when($filters['search'] ?? null, function ($q, $term) {
            $term = trim($term);
            $like = '%' . $term . '%';

            $q->where(function ($qq) use ($like) {
                $qq->where('cargas_combustible.ubicacion', 'like', $like)
                   ->orWhere('cargas_combustible.destino', 'like', $like)
                   ->orWhere('cargas_combustible.observaciones', 'like', $like)
                   ->orWhere('cargas_combustible.custodio', 'like', $like)
                   ->orWhere('cargas_combustible.tipo_combustible', 'like', $like)
                   ->orWhereRaw("CAST(cargas_combustible.id AS CHAR) LIKE ?", [$like])
                   ->orWhereRaw("DATE_FORMAT(cargas_combustible.fecha, '%Y-%m-%d') LIKE ?", [$like])
                   ->orWhereRaw("CAST(cargas_combustible.litros AS CHAR) LIKE ?", [$like])
                   ->orWhereRaw("CAST(cargas_combustible.precio AS CHAR) LIKE ?", [$like])
                   ->orWhereRaw("CAST(cargas_combustible.total  AS CHAR) LIKE ?", [$like])
                   ->orWhereRaw("CAST(cargas_combustible.rendimiento AS CHAR) LIKE ?", [$like])
                   ->orWhere('vehiculos.unidad', 'like', $like)
                   ->orWhere('vehiculos.placa',  'like', $like)
                   ->orWhereRaw("CONCAT_WS(' ', operadores.nombre, operadores.apellido_paterno, operadores.apellido_materno) LIKE ?", [$like]);
            });
        });

        // --- FILTROS ---
        $query->when($filters['vehiculo_id'] ?? null, fn($q, $id) => $q->where('cargas_combustible.vehiculo_id', $id));
        $query->when($filters['operador_id'] ?? null, fn($q, $id) => $q->where('cargas_combustible.operador_id', $id));

        $query->when($filters['ubicacion'] ?? null, function ($q, $u) {
            if ($u !== '') $q->where('cargas_combustible.ubicacion', $u);
        });

        $query->when($filters['tipo_combustible'] ?? null, function ($q, $t) {
            if ($t !== '') $q->where('cargas_combustible.tipo_combustible', $t);
        });

        if (!empty($filters['from'])) $query->whereDate('cargas_combustible.fecha', '>=', $filters['from']);
        if (!empty($filters['to']))   $query->whereDate('cargas_combustible.fecha', '<=', $filters['to']);

        $ranges = [
            ['litros', 'litros_min', '>='], ['litros', 'litros_max', '<='],
            ['precio', 'precio_min', '>='], ['precio', 'precio_max', '<='],
            ['total',  'total_min',  '>='], ['total',  'total_max',  '<='],
            ['rendimiento', 'rend_min', '>='], ['rendimiento', 'rend_max', '<='],
            ['km_inicial',  'km_ini_min', '>='], ['km_inicial',  'km_ini_max', '<='],
            ['km_final',    'km_fin_min', '>='], ['km_final',    'km_fin_max', '<='],
            ['recorrido',   'rec_min', '>='],   ['recorrido',    'rec_max', '<='], // üëà agregado
        ];
        foreach ($ranges as [$col, $key, $op]) {
            if (isset($filters[$key]) && $filters[$key] !== '') {
                $query->where("cargas_combustible.$col", $op, $filters[$key]);
            }
        }

        $query->when($filters['destino']  ?? null, fn($q, $v) => $q->where('cargas_combustible.destino', 'like', '%'.$v.'%'));
        $query->when($filters['custodio'] ?? null, fn($q, $v) => $q->where('cargas_combustible.custodio','like', '%'.$v.'%'));

        $map = [
            'id'               => 'cargas_combustible.id',
            'fecha'            => 'cargas_combustible.fecha',
            'ubicacion'        => 'cargas_combustible.ubicacion',
            'tipo_combustible' => 'cargas_combustible.tipo_combustible',
            'litros'           => 'cargas_combustible.litros',
            'precio'           => 'cargas_combustible.precio',
            'total'            => 'cargas_combustible.total',
            'rendimiento'      => 'cargas_combustible.rendimiento',
            'km_inicial'       => 'cargas_combustible.km_inicial',
            'km_final'         => 'cargas_combustible.km_final',
            'recorrido'        => 'cargas_combustible.recorrido', // üëà agregado
            'vehiculo'         => 'vehiculos.unidad',
            'placa'            => 'vehiculos.placa',
            'operador'         => null,
        ];

        $by  = $filters['sort_by'] ?? 'fecha';
        $dir = strtolower($filters['sort_dir'] ?? 'desc');
        $dir = in_array($dir, ['asc','desc'], true) ? $dir : 'desc';

        if ($by === 'operador') {
            $query->orderByRaw("CONCAT_WS(' ', operadores.nombre, operadores.apellido_paterno, operadores.apellido_materno) {$dir}");
        } else {
            $col = $map[$by] ?? $map['fecha'];
            $query->orderBy($col, $dir);
        }

        return $query;
    }
}

Controlador CargaCombustible 

<?php

namespace App\Http\Controllers;

use App\Models\CargaCombustible;
use App\Models\Operador;
use App\Models\Vehiculo;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Validation\ValidationException;
use Carbon\Carbon;

class CargaCombustibleController extends Controller
{
    public function index(Request $request)
    {
        $filters = $request->only([
            'search',
            'vehiculo_id', 'operador_id',
            'ubicacion', 'tipo_combustible',
            'from', 'to',
            'litros_min','litros_max',
            'precio_min','precio_max',
            'total_min','total_max',
            'rend_min','rend_max',
            'km_ini_min','km_ini_max',
            'km_fin_min','km_fin_max',
            'destino','custodio',
            'sort_by','sort_dir',
        ]);

        // Incluye od√≥metro en el listado para filtros (si quisieras usarlos en offcanvas)
        $vehiculos = Vehiculo::orderBy('unidad')->get(['id','unidad','placa','kilometros']);
        $operadores = Operador::select('id','nombre','apellido_paterno','apellido_materno')
            ->orderBy('nombre')->orderBy('apellido_paterno')->get();

        $ubicaciones = CargaCombustible::UBICACIONES;
        $tipos       = CargaCombustible::TIPOS_COMBUSTIBLE;

        $cargas = CargaCombustible::query()
            ->with(['vehiculo','operador'])
            ->filter($filters)
            ->paginate(25)
            ->withQueryString();

        return view('cargas.index', compact('cargas','vehiculos','operadores','ubicaciones','tipos'));
    }

    public function create()
    {
        return view('cargas.create', [
            'carga'       => new CargaCombustible(),
            'operadores'  => Operador::orderBy('nombre')->get(),
            // Traemos kilometros para autorrellenar KM Inicial por JS
            'vehiculos'   => Vehiculo::orderBy('unidad')->get(['id','unidad','placa','kilometros']),
            'ubicaciones' => CargaCombustible::UBICACIONES,
            'tipos'       => CargaCombustible::TIPOS_COMBUSTIBLE,
        ]);
    }

    public function store(Request $request)
    {
        // Validaci√≥n base (NO aceptamos km_inicial del request: es derivado del od√≥metro)
        $data = $request->validate([
            'ubicacion'        => ['nullable', 'in:' . implode(',', CargaCombustible::UBICACIONES)],
            'fecha'            => ['required', 'date'],
            'precio'           => ['required', 'numeric', 'min:0'],
            'tipo_combustible' => ['required', 'in:Magna,Diesel,Premium'],
            'litros'           => ['required', 'numeric', 'min:0.001'],
            'custodio'         => ['nullable', 'string', 'max:255'],
            'operador_id'      => ['required', 'exists:operadores,id'],
            'vehiculo_id'      => ['required', 'exists:vehiculos,id'],
            'km_final'         => ['required', 'integer', 'min:0'],
            'destino'          => ['nullable', 'string', 'max:255'],
            'observaciones'    => ['nullable', 'string', 'max:2000'],
        ]);

        return DB::transaction(function () use ($data) {
            // Bloqueamos el veh√≠culo para lectura consistente del od√≥metro
            $vehiculo = Vehiculo::lockForUpdate()->findOrFail($data['vehiculo_id']);
            $kmInicial = $vehiculo->kilometros; // puede ser null si no hay historial

            // Regla: si hay od√≥metro previo, km_final debe ser >= km_inicial
            if (!is_null($kmInicial) && $data['km_final'] < $kmInicial) {
                throw ValidationException::withMessages([
                    'km_final' => "El KM final ({$data['km_final']}) no puede ser menor que el od√≥metro actual del veh√≠culo ({$kmInicial}).",
                ]);
            }

            // Derivados
            $this->applyDerived($data, $kmInicial);

            // Guardamos la carga
            $carga = new CargaCombustible();
            $carga->forceFill($data)->save();

            // Actualizamos od√≥metro del veh√≠culo con el KM final de esta carga
            $vehiculo->update(['kilometros' => $data['km_final']]);

            return redirect()->route('cargas.index')
                ->with('success', 'Carga registrada y od√≥metro del veh√≠culo actualizado.');
        });
    }

    public function edit(CargaCombustible $carga)
    {
        return view('cargas.edit', [
            'carga'       => $carga,
            'operadores'  => Operador::orderBy('nombre')->get(),
            // Incluye od√≥metro por si deseas usarlo en la UI
            'vehiculos'   => Vehiculo::orderBy('unidad')->get(['id','unidad','placa','kilometros']),
            'ubicaciones' => CargaCombustible::UBICACIONES,
            'tipos'       => CargaCombustible::TIPOS_COMBUSTIBLE,
        ]);
    }

    public function update(Request $request, CargaCombustible $carga)
    {
        $data = $request->validate([
            'ubicacion'        => ['nullable', 'in:' . implode(',', CargaCombustible::UBICACIONES)],
            'fecha'            => ['required', 'date'],
            'precio'           => ['required', 'numeric', 'min:0'],
            'tipo_combustible' => ['required', 'in:Magna,Diesel,Premium'],
            'litros'           => ['required', 'numeric', 'min:0.001'],
            'custodio'         => ['nullable', 'string', 'max:255'],
            'operador_id'      => ['required', 'exists:operadores,id'],
            'vehiculo_id'      => ['required', 'exists:vehiculos,id'],
            'km_final'         => ['required', 'integer', 'min:0'],
            'destino'          => ['nullable', 'string', 'max:255'],
            'observaciones'    => ['nullable', 'string', 'max:2000'],
        ]);

        return DB::transaction(function () use ($carga, $data) {
            // Si cambia el veh√≠culo, el c√°lculo de km_inicial se basa en la carga previa del NUEVO veh√≠culo
            $vehiculo = Vehiculo::lockForUpdate()->findOrFail($data['vehiculo_id']);

            // Carga previa (por fecha e id) del mismo veh√≠culo para definir km_inicial l√≥gico
            $previa = CargaCombustible::where('vehiculo_id', $vehiculo->id)
                ->where(function($q) use ($carga, $data){
                    $fechaNueva = $data['fecha'];
                    $q->where('fecha','<', $fechaNueva)
                      ->orWhere(function($q2) use ($fechaNueva, $carga){
                          $q2->where('fecha', $fechaNueva)->where('id','<', $carga->id);
                      });
                })
                ->orderBy('fecha','desc')->orderBy('id','desc')->first();

            $kmInicial = $previa?->km_final;

            // Si hay od√≥metro l√≥gico previo, validar km_final
            if (!is_null($kmInicial) && $data['km_final'] < $kmInicial) {
                throw ValidationException::withMessages([
                    'km_final' => "El KM final ({$data['km_final']}) no puede ser menor que el KM final de la carga previa ({$kmInicial}).",
                ]);
            }

            // Derivados
            $this->applyDerived($data, $kmInicial);

            // Guardamos cambios de la carga
            $carga->forceFill($data)->save();

            // Si esta carga qued√≥ como la m√°s reciente del veh√≠culo, sincroniza od√≥metro
            $ultima = CargaCombustible::where('vehiculo_id', $vehiculo->id)
                ->orderBy('fecha','desc')->orderBy('id','desc')->first();

            if ($ultima && $ultima->id === $carga->id) {
                $vehiculo->update(['kilometros' => $data['km_final']]);
            }

            return redirect()->route('cargas.index')
                ->with('success', 'Carga actualizada correctamente.');
        });
    }

    public function destroy(CargaCombustible $carga)
    {
        return DB::transaction(function () use ($carga) {
            $vehiculoId = $carga->vehiculo_id;

            // ¬øEra la m√°s reciente?
            $esUltima = CargaCombustible::where('vehiculo_id', $vehiculoId)
                ->orderBy('fecha','desc')->orderBy('id','desc')->value('id') === $carga->id;

            $deleted = $carga->delete();

            // Re‚Äêsincroniza od√≥metro si borraste la √∫ltima
            if ($deleted && $esUltima) {
                $vehiculo = Vehiculo::lockForUpdate()->find($vehiculoId);
                if ($vehiculo) {
                    $nuevaUltima = CargaCombustible::where('vehiculo_id', $vehiculoId)
                        ->orderBy('fecha','desc')->orderBy('id','desc')->first();
                    $vehiculo->update(['kilometros' => $nuevaUltima?->km_final]);
                }
            }

            return redirect()->route('cargas.index')
                ->with('success', $deleted ? 'Carga eliminada correctamente.' : 'No se pudo eliminar la carga.');
        });
    }

    // ===================== Helpers =====================

    /**
     * Aplica campos derivados a $data y fija km_inicial desde $kmInicial
     */
    protected function applyDerived(array &$data, ?int $kmInicial): void
    {
        // Mes en espa√±ol capitalizado (Enero, Febrero, ‚Ä¶)
        $data['mes'] = ucfirst(Carbon::parse($data['fecha'])->locale('es')->translatedFormat('F'));

        // Total = precio * litros
        $data['total'] = round(((float)$data['precio']) * ((float)$data['litros']), 2);

        // Fijamos km_inicial desde od√≥metro/carga previa
        $data['km_inicial'] = $kmInicial;

        // Recorrido / Rendimiento
        $recorrido = (!is_null($kmInicial) && isset($data['km_final']))
            ? max(0, (int)$data['km_final'] - (int)$kmInicial)
            : null;

        $data['recorrido'] = is_null($recorrido) ? null : (int)$recorrido;

        $data['rendimiento'] = (!is_null($recorrido) && (float)$data['litros'] > 0)
            ? round($recorrido / (float)$data['litros'], 2)
            : null;

        // Diferencia (tu f√≥rmula base de referencia con factor 14 km/L)
        if (!is_null($recorrido) && isset($data['litros'], $data['precio'])) {
            $data['diferencia'] = round(-(((float)$data['litros'] - ($recorrido / 14)) * (float)$data['precio']), 2);
        } else {
            $data['diferencia'] = null;
        }
    }

    // ===================== API M√ìVIL =====================

    /**
     * API: crea una carga asociando el operador mediante el usuario autenticado.
     * La app NO debe enviar operador_id.
     */
    public function storeApi(Request $request)
    {
        $data = $request->validate([
            'ubicacion'        => ['nullable', 'in:' . implode(',', CargaCombustible::UBICACIONES)],
            'fecha'            => ['required', 'date'],
            'precio'           => ['required', 'numeric', 'min:0'],
            'tipo_combustible' => ['required', 'in:Magna,Diesel,Premium'],
            'litros'           => ['required', 'numeric', 'min:0.001'],
            'custodio'         => ['nullable', 'string', 'max:255'],
            'vehiculo_id'      => ['required', 'exists:vehiculos,id'],
            'km_final'         => ['required', 'integer', 'min:0'],
            'destino'          => ['nullable', 'string', 'max:255'],
            'observaciones'    => ['nullable', 'string', 'max:2000'],
        ]);

        $user = $request->user();
        $operador = Operador::where('user_id', $user->id)->first();

        if (!$operador) {
            return response()->json([
                'message' => 'El usuario autenticado no tiene un operador asociado.'
            ], 422);
        }

        return DB::transaction(function () use ($data, $operador) {
            $vehiculo = Vehiculo::lockForUpdate()->findOrFail($data['vehiculo_id']);
            $kmInicial = $vehiculo->kilometros;

            if (!is_null($kmInicial) && $data['km_final'] < $kmInicial) {
                return response()->json([
                    'errors' => ['km_final' => ["El KM final ({$data['km_final']}) no puede ser menor que el od√≥metro actual del veh√≠culo ({$kmInicial})."]]
                ], 422);
            }

            $data['operador_id'] = $operador->id;

            $this->applyDerived($data, $kmInicial);

            $carga = new CargaCombustible();
            $carga->forceFill($data)->save();

            // Actualizamos od√≥metro del veh√≠culo
            $vehiculo->update(['kilometros' => $data['km_final']]);

            return response()->json(
                $carga->load([
                    'vehiculo:id,unidad,placa',
                    'operador:id,nombre,apellido_paterno,apellido_materno'
                ]),
                201
            );
        });
    }
}

Lo que quiero es lo seguiente:

reconocimiento de imagenes a usar gpt40 mini
con una key de open ai 

ser√°n 3 vistas

=Vista del ticket=
Se toma o se sube foto del ticket y se llenan los datos que dependen del ticket (FECHA DE CARGA, tipo de combustible, LITROS, PRECIO, IMPORTE)
el usuario valida los datos le da a continuar

=Vista del voucher=
Se toma o se sube foto del voucher y el sistema verifica que sea igual al importe del ticket
el usuario le da a continuar si si.

=Vista del odometro=
Se toma o se sube foto del odometro para llenar el campo de km final.

=Vista final (?)=
Se muestran lo datos llenados por el reconocimiento de images ademas de campos para llenar los demas datos que no dependen del 
reconocimiento de im√°gen.
El usuario llena los datos y confirma la subida de la carga
Se registra la nueva carga
Las imagenes del ticket y del voucher se quedan guardadas asociadas a su respectiva carga (el funcionmiento es Igual que con las fotos de operadores y vehiculo)

Fin del proceso

Dame el tutorial paso a paso, como si fuera principiante.
Si hace falta actualizar un archivo, pidemelo, te lo doy y me regresas la versi√≥n completa modificada.
Siempre dame las rutas completas de donde colocar cada archivo.

Bueno, ahora si empecemos con el paso 1.
