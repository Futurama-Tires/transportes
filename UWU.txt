Explicame como funciona el proceso de crear las reglas
de verificación.

<?php

namespace App\Http\Controllers;

use App\Models\VerificacionRegla;
use App\Models\CalendarioVerificacion;
use App\Models\VerificacionReglaEstado;
use App\Models\VerificacionReglaDetalle;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Validation\Rule;
use Illuminate\Validation\ValidationException;
use Illuminate\Support\Str;
use Carbon\Carbon;

class VerificacionReglaController extends Controller
{
    /* ===== Catálogos ===== */
    protected function catalogoEstados(): array
    {
        return [
            'Aguascalientes','Baja California','Baja California Sur','Campeche','Chiapas','Chihuahua',
            'Ciudad de México','Coahuila','Colima','Durango','Guanajuato','Guerrero','Hidalgo','Jalisco',
            'México','Michoacán','Morelos','Nayarit','Nuevo León','Oaxaca','Puebla','Querétaro','Quintana Roo',
            'San Luis Potosí','Sinaloa','Sonora','Tabasco','Tamaulipas','Tlaxcala','Veracruz','Yucatán','Zacatecas'
        ];
    }

    protected function mesesES(): array
    {
        return [
            1=>'Enero',2=>'Febrero',3=>'Marzo',4=>'Abril',5=>'Mayo',6=>'Junio',
            7=>'Julio',8=>'Agosto',9=>'Septiembre',10=>'Octubre',11=>'Noviembre',12=>'Diciembre'
        ];
    }

    protected function normalizeEstado(?string $s): string
    {
        $norm = $s ? Str::of($s)->ascii()->upper()->replaceMatches('/\s+/', ' ')->trim() : '';
        $val  = (string) $norm;
        if (in_array($val, ['ESTADO DE MEXICO','MEXICO','EDO MEXICO','EDO. MEX','E DOMEX'], true)) {
            return 'EDO MEX';
        }
        return $val;
    }

    /* ===== UI CRUD ===== */
    public function index()
    {
        $reglas = VerificacionRegla::withCount('periodos')->orderByDesc('created_at')->paginate(15);
        return view('verificacion_reglas.index', ['reglas' => $reglas]);
    }

    public function create()
    {
        // Defaults para precargar la tabla de terminaciones:
        $defaultsSemestral = $this->defaultSemestralDetalles(); // tipo CAMe por bimestres
        $defaultsAnual     = $this->defaultAnualDetalles();     // estilo Jalisco (1→Ene–Feb, 2→Feb–Mar, ...)

        return view('verificacion_reglas.create', [
            'catalogoEstados'  => $this->catalogoEstados(),
            'meses'            => $this->mesesES(),
            'defaultsSemestral'=> $defaultsSemestral,
            'defaultsAnual'    => $defaultsAnual,
            'anioDefault'      => now()->year,
        ]);
    }

    public function edit(VerificacionRegla $verificacion_regla)
    {
        return view('verificacion_reglas.edit', [
            'regla'           => $verificacion_regla,
            'catalogoEstados' => $this->catalogoEstados(),
        ]);
    }

    public function generarForm(VerificacionRegla $verificacion_regla)
    {
        return view('verificacion_reglas.generar', ['regla' => $verificacion_regla]);
    }

    /* ===== Store (1 PASO: crea y genera periodos del año elegido) ===== */
    public function store(Request $request)
    {
        // Validación base de la regla + menú flexible
        $data = $request->validate([
            'nombre'          => ['required', 'string', 'max:255'],
            'version'         => ['nullable', 'string', 'max:50'],
            'frecuencia'      => ['required', Rule::in(['Semestral','Anual'])],
            'notas'           => ['nullable','string'],

            // Menú:
            'anio'            => ['required','integer','min:2000','max:2999'],
            'estados'         => ['required','array','min:1'],
            'estados.*'       => ['string','max:100'],

            // Detalles (tabla de terminaciones → meses)
            'detalles'        => ['required','array'],
        ]);

        $insertados = 0;

        DB::transaction(function () use ($data, &$insertados) {
            $anio = (int) $data['anio'];

            // Normaliza estados seleccionados
            $estadosOriginales = $data['estados'];
            $estadosNorm = array_values(array_unique(array_map(
                fn($e) => $this->normalizeEstado($e),
                $estadosOriginales
            )));

            // 0) Validación extra de disponibilidad (evita choques por año+estado)
            //    - Checa tabla puente verificacion_regla_estados (ocupación lógica)
            //    - Checa también calendario_verificacion por robustez (ocupación materializada)
            $choquesPivot = VerificacionReglaEstado::query()
                ->where('anio', $anio)
                ->whereIn('estado', $estadosNorm)
                ->exists();

            $choquesCal = DB::table('calendario_verificacion')
                ->where('anio', $anio)
                ->whereIn('estado', $estadosNorm)
                ->exists();

            if ($choquesPivot || $choquesCal) {
                throw ValidationException::withMessages([
                    'estados' => 'Uno o más estados ya están asignados en '.$anio.'. Elige otros estados o cambia el año.',
                ]);
            }

            // 1) Crear la regla
            $regla = VerificacionRegla::create([
                'nombre'          => $data['nombre'],
                'version'         => $data['version'] ?? null,
                'status'          => 'published',
                'vigencia_inicio' => Carbon::create($anio, 1, 1)->toDateString(),
                'vigencia_fin'    => Carbon::create($anio, 12, 31)->toDateString(),
                'frecuencia'      => $data['frecuencia'],
                'estados'         => [], // dejamos vacío (usaremos tabla por año)
                'notas'           => $data['notas'] ?? null,
            ]);

            // 2) Guardar estados por AÑO (únicos por anio+estado en DB idealmente)
            foreach ($estadosOriginales as $label) {
                VerificacionReglaEstado::create([
                    'regla_id' => $regla->id,
                    'anio'     => $anio,
                    'estado'   => $label, // normaliza en el mutator del modelo
                ]);
            }

            // 3) Guardar DETALLES (terminación → meses)
            // Estructura esperada:
            //  - Semestral: detalles[d][1][mes_inicio], detalles[d][1][mes_fin], detalles[d][2][mes_inicio], detalles[d][2][mes_fin]
            //  - Anual:     detalles[d][0][mes_inicio], detalles[d][0][mes_fin]
            $seen = [];
            foreach ($data['detalles'] as $terminacionStr => $porSemestre) {
                $terminacion = (int) $terminacionStr;

                foreach ($porSemestre as $sem => $mm) {
                    $semestre = (int) $sem; // 0 (anual), 1 o 2 (semestral)
                    $mi = (int) ($mm['mes_inicio'] ?? 0);
                    $mf = (int) ($mm['mes_fin'] ?? 0);
                    if ($mi < 1 || $mi > 12 || $mf < 1 || $mf > 12) {
                        continue; // ignora filas malformadas
                    }

                    $k = $terminacion.'|'.$semestre.'|'.$mi.'|'.$mf;
                    if (isset($seen[$k])) continue;
                    $seen[$k] = true;

                    VerificacionReglaDetalle::create([
                        'regla_id'   => $regla->id,
                        'frecuencia' => $data['frecuencia'],
                        'terminacion'=> $terminacion,
                        'semestre'   => $semestre,
                        'mes_inicio' => $mi,
                        'mes_fin'    => $mf,
                    ]);
                }
            }

            // 4) GENERAR PERIODOS AUTOMÁTICAMENTE para el año elegido
            $insertados = $this->generarPeriodosCore($regla, $anio, false);
        });

        return redirect()->route('verificacion-reglas.index')
            ->with('success', 'Regla creada y periodos generados ('.$data['anio'].'). Registros: '.$insertados);
    }

    public function update(Request $request, VerificacionRegla $verificacion_regla)
    {
        $data = $request->validate([
            'nombre'     => ['required', 'string', 'max:255'],
            'version'    => ['nullable', 'string', 'max:50'],
            'status'     => ['required', Rule::in(['draft','published','archived'])],
            'frecuencia' => ['required', Rule::in(['Semestral','Anual'])],
            'notas'      => ['nullable','string'],
        ]);

        $verificacion_regla->update([
            'nombre'     => $data['nombre'],
            'version'    => $data['version'] ?? null,
            'status'     => $data['status'],
            'frecuencia' => $data['frecuencia'],
            'notas'      => $data['notas'] ?? null,
        ]);

        return redirect()->route('verificacion-reglas.index')
            ->with('success', 'Regla actualizada.');
    }

    public function destroy(VerificacionRegla $verificacion_regla)
    {
        // Si ya aplicaste CASCADE en la BD, con esto basta:
        $verificacion_regla->delete();

        return redirect()
            ->route('verificacion-reglas.index')
            ->with('success', 'Regla eliminada.');
    }

    /* ===== Generación usando ESTADOS (por año) + DETALLES ===== */
    public function generar(Request $request, VerificacionRegla $verificacion_regla)
    {
        $request->validate([
            'anio'         => ['required', 'integer', 'min:2000', 'max:2999'],
            'sobrescribir' => ['nullable', 'boolean'],
        ]);

        $anio         = (int) $request->integer('anio');
        $sobrescribir = (bool) $request->boolean('sobrescribir');

        $count = $this->generarPeriodosCore($verificacion_regla, $anio, $sobrescribir);

        return redirect()->route('verificacion-reglas.index')
            ->with('success', "Periodos generados para {$verificacion_regla->nombre} ({$anio}). Registros: {$count}");
    }

    /**
     * Núcleo de generación de periodos: arma e inserta/upserta filas en calendario_verificacion.
     * - Usa estados de la regla para ese año (pivot primero; JSON como fallback).
     * - Si $sobrescribir, borra primero lo de ESA regla y año.
     * - Retorna el total de filas existentes para esa regla y año tras la operación.
     */
    private function generarPeriodosCore(VerificacionRegla $regla, int $anio, bool $sobrescribir = false): int
    {
        // Estados asignados a la regla para ese año (normalizados, únicos)
        $estados = VerificacionReglaEstado::query()
            ->where('regla_id', $regla->id)
            ->where('anio', $anio)
            ->pluck('estado')
            ->map(fn($e) => mb_strtoupper(trim($e)))
            ->unique()
            ->values()
            ->all();

        // Backward-compat: si no hay pivot, usa JSON de la regla (si existiera).
        if (empty($estados) && is_array($regla->estados)) {
            $estados = collect($regla->estados)
                ->map(fn($e) => mb_strtoupper(trim($e)))
                ->unique()
                ->values()
                ->all();
        }

        if (empty($estados)) {
            throw ValidationException::withMessages([
                'estados' => 'Esta regla no tiene estados asignados para el año seleccionado.',
            ]);
        }

        // Trae los detalles tal como fueron guardados (una fila por terminación+semestre).
        $detalles = VerificacionReglaDetalle::query()
            ->where('regla_id', $regla->id)
            ->orderBy('terminacion')
            ->get(['terminacion','semestre','mes_inicio','mes_fin']);

        if ($detalles->isEmpty()) {
            throw ValidationException::withMessages([
                'detalles' => 'La regla no tiene calendario por terminación configurado.',
            ]);
        }

        // 1) Deduplicar detalles por combinación clave
        $detalles = $detalles->unique(function ($d) {
            return $d->terminacion.'|'.$d->semestre.'|'.$d->mes_inicio.'|'.$d->mes_fin;
        })->values();

        DB::transaction(function () use ($anio, $sobrescribir, $estados, $detalles, $regla) {
            // 2) Si sobrescribe, borra lo previo de ESTA regla y año (y solo eso)
            if ($sobrescribir) {
                CalendarioVerificacion::query()
                    ->where('regla_id', $regla->id)
                    ->where('anio', $anio)
                    ->delete();
            }

            // 3) Construye filas únicas por (estado, terminacion, mes_inicio, mes_fin, anio)
            $rows     = [];
            $seenKeys = [];

            foreach ($estados as $estado) {
                foreach ($detalles as $d) {
                    $mi  = (int) $d->mes_inicio;
                    $mf  = (int) $d->mes_fin;
                    $sem = (int) $d->semestre; // 1,2 para Semestral; 0 para Anual

                    // Fechas de vigencia dentro del mismo año
                    $desde = Carbon::create($anio, $mi, 1)->startOfMonth();
                    $hasta = Carbon::create($anio, $mf, 1)->endOfMonth();

                    // Clave contra tu índice único (no incluye regla_id ni semestre)
                    $uk = implode('|', [
                        mb_strtoupper($estado),
                        (int) $d->terminacion,
                        $mi, $mf,
                        $anio,
                    ]);
                    if (isset($seenKeys[$uk])) {
                        continue; // evita duplicados en el propio lote
                    }
                    $seenKeys[$uk] = true;

                    // Para anual: guardamos semestre 1 si cae en 1–6, 2 si cae en 7–12
                    $semestreEfectivo = ($sem === 0) ? ($mf <= 6 ? 1 : 2) : $sem;

                    $rows[] = [
                        'estado'         => mb_strtoupper($estado),
                        'terminacion'    => (int) $d->terminacion,
                        'mes_inicio'     => $mi,
                        'mes_fin'        => $mf,
                        'semestre'       => $semestreEfectivo,
                        'frecuencia'     => $regla->frecuencia, // "Semestral" | "Anual"
                        'anio'           => $anio,
                        'vigente_desde'  => $desde->toDateString(),
                        'vigente_hasta'  => $hasta->toDateString(),
                        'regla_id'       => $regla->id,
                        'created_at'     => now(),
                        'updated_at'     => now(),
                    ];
                }
            }

            if (empty($rows)) {
                throw new \RuntimeException('No hay periodos a insertar (verifica los detalles).');
            }

            // 4) Inserta con tolerancia a colisiones del índice único
            DB::table('calendario_verificacion')->upsert(
                $rows,
                ['estado','terminacion','mes_inicio','mes_fin','anio'], // columnas únicas (índice cal_verif_regla_unica)
                ['regla_id','semestre','frecuencia','vigente_desde','vigente_hasta','updated_at'] // columnas a actualizar en choque
            );
        });

        // Total resultante para esa REGLA y AÑO (útil para feedback)
        $count = CalendarioVerificacion::query()
            ->where('regla_id', $regla->id)
            ->where('anio', $anio)
            ->count();

        return $count;
    }

    /* ===== Defaults para precarga en UI ===== */
    protected function defaultSemestralDetalles(): array
    {
        // Mapeo
        // S1: 5-6 Ene-Feb | 7-8 Feb-Mar | 3-4 Mar-Abr | 1-2 Abr-May | 9-0 May-Jun
        // S2: 5-6 Jul-Ago | 7-8 Ago-Sep | 3-4 Sep-Oct | 1-2 Oct-Nov | 9-0 Nov-Dic
        $mapS1 = [
            5 => [1,2], 6 => [1,2],
            7 => [2,3], 8 => [2,3],
            3 => [3,4], 4 => [3,4],
            1 => [4,5], 2 => [4,5],
            9 => [5,6], 0 => [5,6],
        ];

        $out = [];
        foreach (range(0,9) as $d) {
            [$mi1, $mf1] = $mapS1[$d] ?? [1,2];
            $mi2 = $mi1 + 6; if ($mi2 > 12) $mi2 -= 12;
            $mf2 = $mf1 + 6; if ($mf2 > 12) $mf2 -= 12;

            $out[$d][1]['mes_inicio'] = $mi1;
            $out[$d][1]['mes_fin']    = $mf1;
            $out[$d][2]['mes_inicio'] = $mi2;
            $out[$d][2]['mes_fin']    = $mf2;
        }
        return $out;
    }

    protected function defaultAnualDetalles(): array
    {
        // Estilo Jalisco: 1→Ene–Feb, 2→Feb–Mar, ... 0→Nov–Dic
        $map = [
            1 => [1,2], 2 => [2,3], 3 => [3,4], 4 => [4,5], 5 => [5,6],
            6 => [6,7], 7 => [7,8], 8 => [8,9], 9 => [9,10], 0 => [11,12],
        ];
        $out = [];
        foreach (range(0,9) as $d) {
            $mi = $map[$d][0] ?? 1;
            $mf = $map[$d][1] ?? 2;
            $out[$d][0]['mes_inicio'] = $mi;
            $out[$d][0]['mes_fin']    = $mf;
        }
        return $out;
    }

    /* ===== Estados disponibles por AÑO (para el menú) ===== */
    public function estadosDisponibles(Request $request)
    {
        $anio = (int) $request->query('anio', now()->year);

        if ($anio < 2000 || $anio > 2999) {
            return response()->json([
                'ok'          => false,
                'message'     => 'Año inválido',
                'anio'        => $anio,
                'disponibles' => [],
                'ocupados'    => [],
            ], 400);
        }

        // Estados ya ocupados (normalizados) EN CUALQUIER regla para ese año
        $ocupados = VerificacionReglaEstado::where('anio', $anio)
            ->pluck('estado')
            ->map(fn($e) => $this->normalizeEstado($e))
            ->unique()
            ->values()
            ->all();

        $catalogo = $this->catalogoEstados();

        $disponibles = [];
        foreach ($catalogo as $label) {
            $norm = $this->normalizeEstado($label);
            if (!in_array($norm, $ocupados, true)) {
                $disponibles[] = [
                    'value' => $label, // el modelo normaliza al guardar
                    'label' => $label,
                ];
            }
        }

        return response()->json([
            'ok'          => true,
            'anio'        => $anio,
            'disponibles' => $disponibles,
            'ocupados'    => $ocupados,
        ]);
    }
}

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Support\Str;

class VerificacionRegla extends Model
{
    use HasFactory;

    protected $table = 'verificacion_reglas';

    protected $fillable = [
        'nombre',
        'version',
        'status',            // draft|published|archived
        'vigencia_inicio',
        'vigencia_fin',
        'frecuencia',        // Semestral|Anual
        'estados',           // (JSON legible) - opcional
        'notas',
    ];

    protected $casts = [
        'vigencia_inicio' => 'date',
        'vigencia_fin'    => 'date',
        'estados'         => 'array',
    ];

    /* ===================== Constantes / Helpers ===================== */

    public const STATUS = ['draft','published','archived'];
    public const FRECUENCIAS = ['Semestral','Anual'];

    public static function normalizeEstado(?string $s): string
    {
        $norm = Str::of($s ?? '')
            ->ascii()
            ->upper()
            ->replaceMatches('/\s+/', ' ')
            ->trim()
            ->toString();

        if (in_array($norm, ['ESTADO DE MEXICO','MEXICO','EDO MEXICO','EDO. MEX','E DOMEX'], true)) {
            return 'EDO MEX';
        }
        return $norm;
    }

    /** Estados normalizados para un año dado (prefiere tabla puente). */
    public function estadosParaAnio(int $anio): \Illuminate\Support\Collection
    {
        $fromPivot = $this->estadosAsignados()
            ->where('anio', $anio)
            ->pluck('estado')
            ->map(fn($e) => self::normalizeEstado($e))
            ->unique()
            ->values();

        if ($fromPivot->isNotEmpty()) {
            return $fromPivot;
        }

        // Backward-compat (si guardabas estados en JSON)
        $json = collect($this->estados ?? [])
            ->map(fn($e) => self::normalizeEstado($e))
            ->unique()
            ->values();

        return $json;
    }

    /* ===================== Relaciones ===================== */

    public function periodos()
    {
        return $this->hasMany(CalendarioVerificacion::class, 'regla_id');
    }

    public function detalles()
    {
        return $this->hasMany(VerificacionReglaDetalle::class, 'regla_id');
    }

    public function estadosAsignados()
    {
        return $this->hasMany(VerificacionReglaEstado::class, 'regla_id');
    }

    /* ===================== Scopes ===================== */

    public function scopePublished(Builder $q): Builder
    {
        return $q->where('status', 'published');
    }
}

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class VerificacionReglaDetalle extends Model
{
    use HasFactory;

    protected $table = 'verificacion_regla_detalles';

    protected $fillable = [
        'regla_id',
        'frecuencia',  // "Semestral" | "Anual"
        'terminacion',
        'semestre',    // 0 (anual), 1, 2 (semestral)
        'mes_inicio',
        'mes_fin',
    ];

    protected $casts = [
        'terminacion' => 'integer',
        'semestre'    => 'integer',
        'mes_inicio'  => 'integer',
        'mes_fin'     => 'integer',
    ];

    public function regla()
    {
        return $this->belongsTo(VerificacionRegla::class, 'regla_id');
    }
}

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class VerificacionReglaEstado extends Model
{
    use HasFactory;

    protected $table = 'verificacion_regla_estados';

    protected $fillable = [
        'regla_id',
        'anio',
        'estado',
    ];

    protected $casts = [
        'anio' => 'integer',
    ];

    public function regla()
    {
        return $this->belongsTo(VerificacionRegla::class, 'regla_id');
    }

    /* Normalización automática del estado al guardar */
    public function setEstadoAttribute($value): void
    {
        $this->attributes['estado'] = VerificacionRegla::normalizeEstado($value);
    }

    /* Scopes útiles */
    public function scopePorAnio($q, ?int $anio)
    {
        return $anio ? $q->where('anio', $anio) : $q;
    }
}
